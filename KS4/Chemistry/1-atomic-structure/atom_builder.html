<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Atomic Defender - Build Atoms, Save Earth!</title>
  <style>
    /* ----------------- General Styles ----------------- */
    @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700&family=Orbitron:wght@400;500;700&display=swap');
    
    :root {
      --primary-color: #00BFFF;
      --secondary-color: #6A0DAD;
      --accent-color: #00FF7F;
      --dark-bg: #121212;
      --medium-bg: #1E1E1E;
      --light-bg: #2A2A2A;
      --text-color: #FFFFFF;
      --nucleus-glow: rgba(255, 140, 0, 0.6);
      --electron-color: #4FC3F7;
      --electron-glow: rgba(79, 195, 247, 0.8);
      --shell-color: rgba(255, 255, 255, 0.2);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      margin: 0;
      padding: 0;
      font-family: 'Exo 2', sans-serif;
      background: var(--dark-bg);
      color: var(--text-color);
      overflow: hidden;
      background-image: 
        radial-gradient(circle at 10% 20%, rgba(0, 191, 255, 0.1) 0%, transparent 40%),
        radial-gradient(circle at 90% 80%, rgba(106, 13, 173, 0.1) 0%, transparent 40%);
    }
    
    h1, h2, h3 {
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .centered {
      text-align: center;
    }
    
    button {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: var(--text-color);
      border: none;
      padding: 12px 24px;
      font-size: 1em;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      cursor: pointer;
      margin-top: 20px;
      border-radius: 5px;
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(0, 191, 255, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 0 25px rgba(0, 191, 255, 0.7);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    button::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        to bottom right,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      transform: rotate(45deg);
      transition: all 0.3s ease;
    }
    
    button:hover::after {
      left: 100%;
    }
    
    /* ----------------- Introduction Screens ----------------- */
    #introContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--dark-bg);
      color: var(--text-color);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
      background-image: 
        url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ffffff' fill-opacity='0.03' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='1.5'/%3E%3Ccircle cx='17' cy='3' r='1.5'/%3E%3Ccircle cx='10' cy='10' r='1.5'/%3E%3Ccircle cx='3' cy='17' r='1.5'/%3E%3Ccircle cx='17' cy='17' r='1.5'/%3E%3C/g%3E%3C/svg%3E"),
        radial-gradient(circle at 30% 30%, rgba(106, 13, 173, 0.4) 0%, transparent 70%),
        radial-gradient(circle at 70% 70%, rgba(0, 191, 255, 0.4) 0%, transparent 70%);
    }
    
    .introScreen {
      max-width: 800px;
      padding: 30px;
      margin: 0 20px;
      background: rgba(30, 30, 30, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 30px rgba(0, 191, 255, 0.3);
      animation: fadeIn 0.8s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .introScreen h2 {
      margin-top: 0;
      margin-bottom: 20px;
      color: var(--accent-color);
      text-shadow: 0 0 10px rgba(0, 255, 127, 0.5);
    }
    
    .introScreen p, .introScreen ol {
      font-size: 1.1em;
      line-height: 1.6;
      margin-bottom: 15px;
    }
    
    /* ----------------- Final Screen ----------------- */
    #finalScreen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--dark-bg);
      color: var(--text-color);
      z-index: 1000;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-image: 
        radial-gradient(circle at 30% 30%, rgba(106, 13, 173, 0.4) 0%, transparent 70%),
        radial-gradient(circle at 70% 70%, rgba(0, 191, 255, 0.4) 0%, transparent 70%);
    }
    
    #finalScreen h2 {
      font-size: 3em;
      color: var(--accent-color);
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(0, 255, 127, 0.7);
    }
    
    #finalScoreText {
      font-size: 1.3em;
      margin-bottom: 30px;
      max-width: 600px;
      text-align: center;
      line-height: 1.6;
    }
    
    /* ----------------- Sidebar ----------------- */
    #sidebar {
      width: 280px;
      background: var(--medium-bg);
      padding: 20px;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      float: left;
      box-sizing: border-box;
      height: 100vh;
      position: relative;
      z-index: 10;
      box-shadow: 5px 0 15px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
    }
    
    #sidebar h2 {
      text-align: center;
      margin-bottom: 20px;
      color: var(--primary-color);
      text-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
    }
    
    .element-box {
      width: 100%;
      border: 2px solid rgba(255, 255, 255, 0.1);
      background: var(--light-bg);
      padding: 30px 20px;
      box-sizing: border-box;
      text-align: center;
      margin-top: 5px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 191, 255, 0.2);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .element-box::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(
        circle at center,
        rgba(0, 191, 255, 0.1) 0%,
        transparent 70%
      );
      animation: rotateBg 15s linear infinite;
    }
    
    @keyframes rotateBg {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .mass-number {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 10px;
      position: relative;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .element-info {
      font-size: 3.2em;
      font-weight: bold;
      position: relative;
      color: var(--primary-color);
      text-shadow: 0 0 15px rgba(0, 191, 255, 0.7);
    }
    
    .atomic-number {
      font-size: 1em;
      margin-top: 10px;
      position: relative;
      color: rgba(255, 255, 255, 0.8);
    }
    
    #progressIndicator, #bombIndicator {
      margin-top: 25px;
      font-size: 1.1em;
      text-align: center;
      font-weight: bold;
      padding: 12px;
      border-radius: 8px;
      background: var(--light-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
    }
    
    #bombIndicator {
      color: var(--accent-color);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #bombIndicator::before {
      content: '💣';
      margin-right: 10px;
      font-size: 1.2em;
    }
    
    /* Progress bar styles */
    .progress-container {
      width: 100%;
      height: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      margin-top: 10px;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 5px;
      transition: width 0.5s ease;
      box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
    }
    
    /* ----------------- Atom Builder ----------------- */
    #atomBuilder {
      margin-left: 280px;
      padding: 30px;
      display: none; /* Hidden until after the intro */
      height: 100vh;
      overflow-y: auto;
      background: var(--dark-bg);
      background-image: 
        radial-gradient(circle at 10% 90%, rgba(0, 191, 255, 0.1) 0%, transparent 40%),
        radial-gradient(circle at 90% 10%, rgba(106, 13, 173, 0.1) 0%, transparent 40%);
    }
    
    #atomBuilder h1 {
      text-align: center;
      margin-bottom: 30px;
      color: var(--primary-color);
      text-shadow: 0 0 15px rgba(0, 191, 255, 0.5);
      font-size: 2.5em;
    }
    
    #atomBuilder .section {
      margin-bottom: 30px;
    }
    
    #atomBuilder .section h2 {
      text-align: center;
      margin-bottom: 20px;
      color: var(--accent-color);
    }
    
    #atomContainer {
      position: relative;
      width: 500px;
      height: 500px;
      margin: 0 auto;
      background: radial-gradient(circle at center, rgba(30, 30, 30, 0.6), rgba(18, 18, 18, 0.8));
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      box-shadow: 0 0 40px rgba(0, 191, 255, 0.2), inset 0 0 40px rgba(0, 191, 255, 0.1);
      animation: pulseShadow 4s infinite alternate;
    }
    
    @keyframes pulseShadow {
      0% { box-shadow: 0 0 40px rgba(0, 191, 255, 0.2), inset 0 0 40px rgba(0, 191, 255, 0.1); }
      100% { box-shadow: 0 0 60px rgba(0, 191, 255, 0.4), inset 0 0 60px rgba(0, 191, 255, 0.2); }
    }
    
    /* Nucleus with inputs */
    #nucleus {
      position: absolute;
      width: 120px;
      height: 120px;
      background: radial-gradient(circle at center, #FF8C00, #FF4500);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-sizing: border-box;
      padding-top: 15px;
      z-index: 5;
      text-align: center;
      box-shadow: 0 0 30px var(--nucleus-glow);
      animation: pulse 2s infinite alternate;
    }
    
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 30px var(--nucleus-glow); }
      100% { transform: translate(-50%, -50%) scale(1.05); box-shadow: 0 0 40px var(--nucleus-glow); }
    }
    
    #nucleus .input-row {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 12px;
    }
    
    #nucleus .input-row span {
      font-size: 1.3em;
      margin-right: 8px;
      color: rgba(255, 255, 255, 0.9);
      font-weight: bold;
    }
    
    #nucleus input {
      width: 50px;
      height: 28px;
      text-align: center;
      font-size: 1.1em;
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      color: white;
      font-family: 'Exo 2', sans-serif;
      transition: all 0.3s ease;
    }
    
    #nucleus input:focus {
      outline: none;
      background: rgba(255, 255, 255, 0.25);
      border-color: var(--primary-color);
      box-shadow: 0 0 10px var(--primary-color);
    }
    
    /* Electron shells */
    .shell {
      position: absolute;
      border: 2px dashed var(--shell-color);
      border-radius: 50%;
      pointer-events: none;
      z-index: 1;
      /* Removed rotation animation so electrons stay stationary */
      /* animation: rotate 60s linear infinite; */
    }
    
    /* The following shell-specific animation properties have been commented out */
    #shell1 {
      width: 200px;
      height: 200px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* animation-duration: 15s; */
    }
    
    #shell2 {
      width: 300px;
      height: 300px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* animation-duration: 25s;
         animation-direction: reverse; */
    }
    
    #shell3 {
      width: 400px;
      height: 400px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* animation-duration: 35s; */
    }
    
    #shell4 {
      width: 480px;
      height: 480px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* animation-duration: 45s;
         animation-direction: reverse; */
    }
    
    /* Electron spots */
    .electron-spot {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      background: rgba(20, 20, 20, 0.6);
      text-align: center;
      line-height: 30px;
      font-weight: bold;
      cursor: pointer;
      pointer-events: auto;
      z-index: 3;
      transition: all 0.3s ease;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }
    
    .electron-spot:hover {
      transform: scale(1.1) translate(-45%, -45%);
      background: rgba(30, 30, 30, 0.8);
      box-shadow: 0 0 15px rgba(79, 195, 247, 0.5);
    }
    
    .electron-spot:active {
      transform: scale(0.95) translate(-45%, -45%);
    }
    
    .electron-spot:empty {
      background: rgba(20, 20, 20, 0.6);
    }
    
    .electron-spot:not(:empty) {
      background: var(--electron-color);
      box-shadow: 0 0 15px var(--electron-glow);
    }
    
    #shell1 .spot-top {
      top: 0;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #shell1 .spot-bottom {
      bottom: 0;
      left: 50%;
      transform: translate(-50%, 50%);
    }
    
    .shell.two .spot-top-left {
      top: 0;
      left: 35%;
      transform: translate(-50%, -50%);
    }
    
    .shell.two .spot-top-right {
      top: 0;
      left: 65%;
      transform: translate(-50%, -50%);
    }
    
    .shell.two .spot-bottom-left {
      bottom: 0;
      left: 35%;
      transform: translate(-50%, 50%);
    }
    
    .shell.two .spot-bottom-right {
      bottom: 0;
      left: 65%;
      transform: translate(-50%, 50%);
    }
    
    .shell.two .spot-left-top {
      left: 0;
      top: 35%;
      transform: translate(-50%, -50%);
    }
    
    .shell.two .spot-left-bottom {
      left: 0;
      top: 65%;
      transform: translate(-50%, -50%);
    }
    
    .shell.two .spot-right-top {
      right: 0;
      top: 35%;
      transform: translate(50%, -50%);
    }
    
    .shell.two .spot-right-bottom {
      right: 0;
      top: 65%;
      transform: translate(50%, -50%);
    }
    
    #shell4 .spot-top {
      top: 0;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #shell4 .spot-bottom {
      bottom: 0;
      left: 50%;
      transform: translate(-50%, 50%);
    }
    
    #submitBtn {
      display: block;
      margin: 20px auto;
      min-width: 200px;
      padding: 15px 30px;
      font-size: 1.2em;
    }
    
    #score {
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      color: var(--accent-color);
      text-shadow: 0 0 10px rgba(0, 255, 127, 0.5);
      margin-top: 20px;
    }
    
    /* ----------------- Electron Clash Mini-Game ----------------- */
    #electronClash {
      display: none;
      padding: 20px;
      text-align: center;
      background: linear-gradient(135deg, #000046, #1CB5E0);
      background-image: 
        url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ffffff' fill-opacity='0.05' fill-rule='evenodd'%3E%3Ccircle cx='50' cy='50' r='1.5'/%3E%3C/g%3E%3C/svg%3E"),
        linear-gradient(135deg, #000046, #1CB5E0);
      color: #fff;
      height: 100vh;
      box-sizing: border-box;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 100;
    }
    
    #electronClash h1 {
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
      color: var(--accent-color);
    }
    
    #clashCanvas {
      background: radial-gradient(circle at center, #000, #222);
      display: block;
      margin: 20px auto;
      border: 3px solid #00ffff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 0, 0, 0.8);
      border-radius: 8px;
    }
    
    #clashScore {
      font-size: 1.5em;
      margin-bottom: 15px;
      color: #ff9900;
      text-shadow: 0 0 15px rgba(255, 153, 0, 0.5);
      font-family: 'Orbitron', sans-serif;
      background: rgba(0, 0, 0, 0.3);
      display: inline-block;
      padding: 10px 20px;
      border-radius: 10px;
      border: 1px solid rgba(255, 153, 0, 0.3);
    }
    
    #exitClashBtn {
      background: linear-gradient(135deg, #FF4500, #FF8C00);
      box-shadow: 0 0 15px rgba(255, 69, 0, 0.5);
      margin-top: 20px;
    }
    
    #exitClashBtn:hover {
      box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
    }
    
    /* ----------------- Game HUD ----------------- */
    #gameHUD {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      z-index: 50;
      box-shadow: 0 0 20px rgba(0, 191, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      font-family: 'Orbitron', sans-serif;
    }
    
    #gameHUD span {
      margin: 0 10px;
      color: var(--accent-color);
    }
    
    /* ----------------- Key ----------------- */
    #key {
      position: fixed;
      bottom: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.9em;
      z-index: 50;
      box-shadow: 0 0 15px rgba(0, 191, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
    }
    
    /* ----------------- Feedback Effects ----------------- */
    .correct-feedback {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3em;
      font-weight: bold;
      color: var(--accent-color);
      text-shadow: 0 0 20px rgba(0, 255, 127, 0.7);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      animation: fadeInOut 1.5s forwards;
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    
    .incorrect-feedback {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5em;
      font-weight: bold;
      color: #FF4500;
      text-shadow: 0 0 20px rgba(255, 69, 0, 0.7);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      animation: shake 1s forwards;
    }
    
    @keyframes shake {
      0%, 100% { transform: translate(-50%, -50%); opacity: 0; }
      10%, 90% { transform: translate(-52%, -50%); opacity: 1; }
      20%, 80% { transform: translate(-48%, -50%); opacity: 1; }
      30%, 50%, 70% { transform: translate(-54%, -50%); opacity: 1; }
      40%, 60% { transform: translate(-46%, -50%); opacity: 1; }
      95% { opacity: 0; }
    }
    
    /* Tooltip styles */
    .tooltip {
      position: relative;
      display: inline-block;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: rgba(0, 0, 0, 0.8);
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-family: 'Exo 2', sans-serif;
      font-size: 0.9em;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Introduction Screens Container -->
  <div id="introContainer">
    <!-- Intro Screen 1: The Story -->
    <div id="introScreen1" class="introScreen">
      <h2>🚀 The Atomic Defender Initiative</h2>
      <p>
        The galaxy is under attack! Ruthless alien invaders are descending upon Earth, and only one weapon can stop them—<strong>the power of the atom!</strong>
      </p>
      <p>
        As Earth's last line of defense, you must <strong>construct atoms</strong> to create the bombs needed to fight back. Every atom you build correctly arms you with a powerful atomic bomb to use against the alien fleet.
      </p>
      <p>
        The fate of the planet is in your hands. Are you ready to harness the building blocks of the universe and <strong>save humanity?</strong>
      </p>
      <p>
        <strong>💥 Build atoms. Arm the defenses. Fight for survival! 💥</strong>
      </p>
      <button id="nextBtn">Next</button>
    </div>
    <!-- Intro Screen 2: How to Play -->
    <div id="introScreen2" class="introScreen" style="display: none;">
      <h2>🛠️ How to Build Atoms & Save Earth</h2>
      <ol style="text-align: left; max-width: 600px; margin: 0 auto; font-size: 1.1em;">
        <li>
          <strong>Build an Atom</strong><br>
          - Type the number of <strong>protons</strong> and <strong>neutrons</strong> inside the nucleus.<br>
          &nbsp;&nbsp;&nbsp;Example: <code>p: 6 n: 6</code> for Carbon.<br>
          - Click on the <strong>electron shells</strong> to toggle electrons.
        </li>
        <li style="margin-top: 10px;">
          <strong>Check Your Atom</strong><br>
          - Click <strong>Submit</strong> when you think your atom is correct.<br>
          - If correct, you'll receive <strong>a bomb</strong> to use in battle!
        </li>
        <li style="margin-top: 10px;">
          <strong>Defend Earth!</strong><br>
          - Every 5 successful atoms unlocks <strong>60 seconds of Space Invaders</strong>.<br>
          - Use the bombs you've earned (press the <strong>b</strong> key) to blast alien ships.
        </li>
      </ol>
      <p style="margin-top: 20px; font-size: 1.1em;">
        💡 <strong>Tip:</strong> The periodic table holds the secrets—use it wisely!
      </p>
      <button id="startBtn">Start Mission</button>
    </div>
  </div>

  <!-- Final Screen -->
  <div id="finalScreen" class="centered">
    <h2>Mission Complete!</h2>
    <p id="finalScoreText"></p>
    <button id="restartBtn">Begin New Mission</button>
  </div>

  <!-- Sidebar with Element Info -->
  <div id="sidebar">
    <h2>Current Element</h2>
    <div id="elementBox" class="element-box">
      <div class="mass-number" id="massNumber"></div>
      <div class="element-info" id="elementSymbol"></div>
      <div class="atomic-number" id="atomicNumber"></div>
    </div>
    <div id="progressIndicator">
      Atoms Built: 0 / 20
      <div class="progress-container">
        <div class="progress-bar" style="width: 0%"></div>
      </div>
    </div>
    <div id="bombIndicator">Bombs: 0</div>
  </div>

  <!-- Atom Builder Module -->
  <div id="atomBuilder">
    <h1>Atomic Defender: Element Builder</h1>
    <div id="gameArea">
      <div class="section">
        <h2>Construct Your Atom</h2>
        <div id="atomContainer">
          <!-- Electron shells -->
          <div id="shell1" class="shell">
            <div class="electron-spot spot-top" data-shell="1"></div>
            <div class="electron-spot spot-bottom" data-shell="1"></div>
          </div>
          <div id="shell2" class="shell two">
            <div class="electron-spot spot-top-left" data-shell="2"></div>
            <div class="electron-spot spot-top-right" data-shell="2"></div>
            <div class="electron-spot spot-bottom-left" data-shell="2"></div>
            <div class="electron-spot spot-bottom-right" data-shell="2"></div>
            <div class="electron-spot spot-left-top" data-shell="2"></div>
            <div class="electron-spot spot-left-bottom" data-shell="2"></div>
            <div class="electron-spot spot-right-top" data-shell="2"></div>
            <div class="electron-spot spot-right-bottom" data-shell="2"></div>
          </div>
          <div id="shell3" class="shell two">
            <div class="electron-spot spot-top-left" data-shell="3"></div>
            <div class="electron-spot spot-top-right" data-shell="3"></div>
            <div class="electron-spot spot-bottom-left" data-shell="3"></div>
            <div class="electron-spot spot-bottom-right" data-shell="3"></div>
            <div class="electron-spot spot-left-top" data-shell="3"></div>
            <div class="electron-spot spot-left-bottom" data-shell="3"></div>
            <div class="electron-spot spot-right-top" data-shell="3"></div>
            <div class="electron-spot spot-right-bottom" data-shell="3"></div>
          </div>
          <div id="shell4" class="shell">
            <div class="electron-spot spot-top" data-shell="4"></div>
            <div class="electron-spot spot-bottom" data-shell="4"></div>
          </div>
          <!-- Nucleus with inputs -->
          <div id="nucleus">
            <div class="input-row">
              <span>p</span>
              <input type="number" id="inputProtons" min="0">
            </div>
            <div class="input-row">
              <span>n</span>
              <input type="number" id="inputNeutrons" min="0">
            </div>
          </div>
        </div>
      </div>
      <div class="section">
        <button id="submitBtn">Submit Atom</button>
        <p id="score"></p>
      </div>
    </div>
  </div>

  <!-- Electron Clash Mini-Game Module -->
  <div id="electronClash">
    <h1>Electron Clash: Alien Defense</h1>
    <canvas id="clashCanvas" width="700" height="500"></canvas>
    <div id="clashScore">Score: 0 | Time: 0s | Bombs: 0</div>
    <button id="exitClashBtn">Return to Atom Builder</button>
  </div>

  <!-- Game HUD -->
  <div id="gameHUD" style="display: none;">
    <span class="tooltip">
      Press SPACE to shoot
      <span class="tooltiptext">Shoot regular lasers at the alien ships</span>
    </span>
    <span class="tooltip">
      Press B to use bombs
      <span class="tooltiptext">Launch powerful atomic bombs that create an area explosion</span>
    </span>
  </div>

  <!-- Key -->
  <div id="key">
    Key: p = proton, n = neutron, e⁻ = electron, b = bomb shot
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      /***************** INTRODUCTION SCREENS *****************/
      const introContainer = document.getElementById("introContainer");
      const introScreen1 = document.getElementById("introScreen1");
      const introScreen2 = document.getElementById("introScreen2");
      const nextBtn = document.getElementById("nextBtn");
      const startBtn = document.getElementById("startBtn");
      const gameHUD = document.getElementById("gameHUD");

      nextBtn.addEventListener("click", function() {
        introScreen1.style.display = "none";
        introScreen2.style.display = "block";
      });

      startBtn.addEventListener("click", function() {
        introContainer.style.display = "none";
        document.getElementById("atomBuilder").style.display = "block";
        gameHUD.style.display = "flex";
        // Play start sound if desired
        playSound('start');
      });

      /***************** FINAL SCREEN *****************/
      const finalScreen = document.getElementById("finalScreen");
      const finalScoreText = document.getElementById("finalScoreText");
      const restartBtn = document.getElementById("restartBtn");
      if(restartBtn){
        restartBtn.addEventListener("click", function() {
          // Reset game state.
          availableElements = allElements.slice();
          atomScore = 0;
          attemptCount = 0;
          solvedCount = 0;
          bombs = 0;
          clashScoreTotal = 0;
          updateProgress();
          finalScreen.style.display = "none";
          document.getElementById("atomBuilder").style.display = "block";
          gameHUD.style.display = "flex";
          newAtomRound();
          // Play restart sound
          playSound('start');
        });
      }

      /***************** SOUND EFFECTS *****************/
      function playSound(type) {
        // Create audio context if needed
        if (!window.audioContext) {
          try {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          } catch(e) {
            console.warn('Web Audio API not supported');
            return;
          }
        }
        
        const ctx = window.audioContext;
        
        switch(type) {
          case 'correct':
            // Play success sound
            const correctOsc = ctx.createOscillator();
            const correctGain = ctx.createGain();
            correctOsc.connect(correctGain);
            correctGain.connect(ctx.destination);
            correctOsc.type = 'sine';
            correctOsc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
            correctOsc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1); // E5
            correctOsc.frequency.setValueAtTime(783.99, ctx.currentTime + 0.2); // G5
            correctGain.gain.setValueAtTime(0.2, ctx.currentTime);
            correctGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            correctOsc.start();
            correctOsc.stop(ctx.currentTime + 0.5);
            break;
            
          case 'incorrect':
            // Play error sound
            const errorOsc = ctx.createOscillator();
            const errorGain = ctx.createGain();
            errorOsc.connect(errorGain);
            errorGain.connect(ctx.destination);
            errorOsc.type = 'sawtooth';
            errorOsc.frequency.setValueAtTime(220, ctx.currentTime);
            errorOsc.frequency.setValueAtTime(196, ctx.currentTime + 0.2);
            errorGain.gain.setValueAtTime(0.2, ctx.currentTime);
            errorGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
            errorOsc.start();
            errorOsc.stop(ctx.currentTime + 0.4);
            break;
            
          case 'shoot':
            // Play shoot sound
            const shootOsc = ctx.createOscillator();
            const shootGain = ctx.createGain();
            shootOsc.connect(shootGain);
            shootGain.connect(ctx.destination);
            shootOsc.type = 'sine';
            shootOsc.frequency.setValueAtTime(880, ctx.currentTime);
            shootOsc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.1);
            shootGain.gain.setValueAtTime(0.1, ctx.currentTime);
            shootGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
            shootOsc.start();
            shootOsc.stop(ctx.currentTime + 0.1);
            break;
            
          case 'bomb':
            // Play bomb sound
            const bombOsc = ctx.createOscillator();
            const bombNoise = ctx.createOscillator();
            const bombGain = ctx.createGain();
            const bombNoiseGain = ctx.createGain();
            
            bombOsc.connect(bombGain);
            bombNoise.connect(bombNoiseGain);
            bombGain.connect(ctx.destination);
            bombNoiseGain.connect(ctx.destination);
            
            bombOsc.type = 'triangle';
            bombOsc.frequency.setValueAtTime(220, ctx.currentTime);
            bombOsc.frequency.exponentialRampToValueAtTime(55, ctx.currentTime + 0.3);
            bombGain.gain.setValueAtTime(0.3, ctx.currentTime);
            bombGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            
            bombNoise.type = 'sawtooth';
            bombNoise.frequency.setValueAtTime(100, ctx.currentTime);
            bombNoiseGain.gain.setValueAtTime(0.2, ctx.currentTime);
            bombNoiseGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            
            bombOsc.start();
            bombNoise.start();
            bombOsc.stop(ctx.currentTime + 0.5);
            bombNoise.stop(ctx.currentTime + 0.5);
            break;
            
          case 'explosion':
            // Play explosion sound
            const explosionOsc = ctx.createOscillator();
            const noiseFilter = ctx.createBiquadFilter();
            const explosionGain = ctx.createGain();
            
            explosionOsc.connect(noiseFilter);
            noiseFilter.connect(explosionGain);
            explosionGain.connect(ctx.destination);
            
            explosionOsc.type = 'sawtooth';
            explosionOsc.frequency.setValueAtTime(100, ctx.currentTime);
            explosionOsc.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.5);
            
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(1000, ctx.currentTime);
            noiseFilter.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.5);
            
            explosionGain.gain.setValueAtTime(0.3, ctx.currentTime);
            explosionGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            
            explosionOsc.start();
            explosionOsc.stop(ctx.currentTime + 0.5);
            break;
            
          case 'start':
            // Play game start sound
            const startOsc = ctx.createOscillator();
            const startGain = ctx.createGain();
            startOsc.connect(startGain);
            startGain.connect(ctx.destination);
            startOsc.type = 'sine';
            
            // Play an ascending arpeggio
            startOsc.frequency.setValueAtTime(262, ctx.currentTime); // C4
            startOsc.frequency.setValueAtTime(330, ctx.currentTime + 0.1); // E4
            startOsc.frequency.setValueAtTime(392, ctx.currentTime + 0.2); // G4
            startOsc.frequency.setValueAtTime(523, ctx.currentTime + 0.3); // C5
            
            startGain.gain.setValueAtTime(0.2, ctx.currentTime);
            startGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
            
            startOsc.start();
            startOsc.stop(ctx.currentTime + 0.4);
            break;
        }
      }

      /***************** ATOM BUILDER CODE *****************/
      const allElements = [
        { name: "Hydrogen", symbol: "H", protons: 1, neutrons: 0 },
        { name: "Helium", symbol: "He", protons: 2, neutrons: 2 },
        { name: "Lithium", symbol: "Li", protons: 3, neutrons: 4 },
        { name: "Beryllium", symbol: "Be", protons: 4, neutrons: 5 },
        { name: "Boron", symbol: "B", protons: 5, neutrons: 6 },
        { name: "Carbon", symbol: "C", protons: 6, neutrons: 6 },
        { name: "Nitrogen", symbol: "N", protons: 7, neutrons: 7 },
        { name: "Oxygen", symbol: "O", protons: 8, neutrons: 8 },
        { name: "Fluorine", symbol: "F", protons: 9, neutrons: 10 },
        { name: "Neon", symbol: "Ne", protons: 10, neutrons: 10 },
        { name: "Sodium", symbol: "Na", protons: 11, neutrons: 12 },
        { name: "Magnesium", symbol: "Mg", protons: 12, neutrons: 12 },
        { name: "Aluminium", symbol: "Al", protons: 13, neutrons: 14 },
        { name: "Silicon", symbol: "Si", protons: 14, neutrons: 14 },
        { name: "Phosphorus", symbol: "P", protons: 15, neutrons: 16 },
        { name: "Sulfur", symbol: "S", protons: 16, neutrons: 16 },
        { name: "Chlorine", symbol: "Cl", protons: 17, neutrons: 18 },
        { name: "Argon", symbol: "Ar", protons: 18, neutrons: 18 },
        { name: "Potassium", symbol: "K", protons: 19, neutrons: 20 },
        { name: "Calcium", symbol: "Ca", protons: 20, neutrons: 20 }
      ];

      let availableElements = allElements.slice();
      let currentElement;
      let atomScore = 0;
      let attemptCount = 0;
      let solvedCount = 0;
      let bombs = 0;

      function getRandomElement() {
        if (availableElements.length === 0) return null;
        const index = Math.floor(Math.random() * availableElements.length);
        return { element: availableElements[index], index };
      }

      function updateSidebar(element) {
        const massNumber = element.protons + element.neutrons;
        document.getElementById('massNumber').innerText = massNumber;
        document.getElementById('elementSymbol').innerText = element.symbol;
        document.getElementById('atomicNumber').innerText = element.protons;
      }

      function updateProgress() {
        const progressPercentage = (solvedCount / allElements.length) * 100;
        document.getElementById('progressIndicator').innerHTML = 
          `Atoms Built: ${solvedCount} / ${allElements.length}
           <div class="progress-container">
             <div class="progress-bar" style="width: ${progressPercentage}%"></div>
           </div>`;
        document.getElementById('bombIndicator').innerText = `Bombs: ${bombs}`;
      }

      function getRequiredElectrons(atomicNumber) {
        let electrons = atomicNumber;
        const shell1 = Math.min(2, electrons);
        electrons -= shell1;
        const shell2 = Math.min(8, electrons);
        electrons -= shell2;
        const shell3 = Math.min(8, electrons);
        electrons -= shell3;
        const shell4 = electrons;
        return { shell1, shell2, shell3, shell4 };
      }

      function newAtomRound() {
        document.getElementById('inputProtons').value = "";
        document.getElementById('inputNeutrons').value = "";
        document.querySelectorAll('.electron-spot').forEach(spot => spot.innerHTML = "");

        const randomPick = getRandomElement();
        if (!randomPick) {
          // All elements solved! Show final screen.
          document.getElementById("atomBuilder").style.display = "none";
          gameHUD.style.display = "none";
          finalScoreText.innerText = `Mission accomplished! Your overall score is ${atomScore} points. You built ${solvedCount} atoms and achieved a total Electron Clash score of ${clashScoreTotal} points!`;
          finalScreen.style.display = "flex";
          return;
        }
        currentElement = randomPick.element;
        updateSidebar(currentElement);
        updateProgress();
        document.getElementById('score').innerText = "";
      }

      function toggleElectron() {
        if (this.innerHTML.trim() === "") {
          this.innerHTML = "e⁻";
          playSound('shoot');
        } else {
          this.innerHTML = "";
        }
      }
      document.querySelectorAll('.electron-spot').forEach(spot => {
        spot.addEventListener("click", toggleElectron);
      });

      document.getElementById('submitBtn').addEventListener("click", function() {
        const inputProtons = parseInt(document.getElementById('inputProtons').value, 10);
        const inputNeutrons = parseInt(document.getElementById('inputNeutrons').value, 10);
        let nucleusCorrect = (inputProtons === currentElement.protons && inputNeutrons === currentElement.neutrons);

        const electronCount = { shell1: 0, shell2: 0, shell3: 0, shell4: 0 };
        document.querySelectorAll('.electron-spot').forEach(spot => {
          const shell = spot.getAttribute("data-shell");
          if (spot.innerHTML.trim() !== "") electronCount["shell" + shell]++;
        });
        const req = getRequiredElectrons(currentElement.protons);
        let electronsCorrect = (electronCount.shell1 === req.shell1) &&
                               (electronCount.shell2 === req.shell2) &&
                               (electronCount.shell3 === req.shell3) &&
                               (electronCount.shell4 === req.shell4);

        let roundScore = 0;
        if(nucleusCorrect) roundScore++;
        if(electronsCorrect) roundScore++;

        attemptCount++;
        if(roundScore === 2) {
          // Create feedback element
          const feedback = document.createElement('div');
          feedback.classList.add('correct-feedback');
          feedback.innerText = `CORRECT! +1 BOMB`;
          document.body.appendChild(feedback);
          
          // Remove feedback after animation completes
          setTimeout(() => {
            document.body.removeChild(feedback);
          }, 1500);
          
          // Play success sound
          playSound('correct');
          
          atomScore++;
          solvedCount++;
          bombs++;  // Award one bomb.
          const indexToRemove = availableElements.findIndex(el => el.symbol === currentElement.symbol);
          if(indexToRemove !== -1) availableElements.splice(indexToRemove, 1);
        } else {
          // Create feedback element
          const feedback = document.createElement('div');
          feedback.classList.add('incorrect-feedback');
          feedback.innerText = `TRY AGAIN!`;
          document.body.appendChild(feedback);
          
          // Remove feedback after animation completes
          setTimeout(() => {
            document.body.removeChild(feedback);
          }, 1000);
          
          // Play error sound
          playSound('incorrect');
        }
        document.getElementById('score').innerText = "Score: " + atomScore;
        updateProgress();

        // Launch mini-game every 5 attempts.
        if(attemptCount % 5 === 0) {
          launchElectronClash();
        } else {
          if(roundScore === 2) {
            // Only move to next atom if correct
            newAtomRound();
          }
        }
      });

      newAtomRound();

      /***************** ELECTRON CLASH MINI-GAME CODE *****************/
      const electronClashDiv = document.getElementById("electronClash");
      const atomBuilderDiv = document.getElementById("atomBuilder");
      const canvas = document.getElementById("clashCanvas");
      const ctx = canvas.getContext("2d");
      let clashScore = 0;
      let clashScoreTotal = 0;
      let clashGameRunning = false;
      let miniGameStartTime = 0;
      const miniGameTimeLimit = 60; // seconds

      // Create background stars
      const stars = [];
      function createStars() {
        for (let i = 0; i < 100; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 1,
            speed: Math.random() * 0.5 + 0.1
          });
        }
      }
      createStars();

      const shooter = {
        x: canvas.width / 2 - 20,
        y: canvas.height - 60,
        width: 40,
        height: 40,
        speed: 6,
        cooldown: 0,
        attack: 1,
        color: '#00ff7f'
      };
      const bulletCooldown = 15;
      const bombCooldown = 40;
      let currentBombCooldown = 0;

      let bullets = [];
      let bombBullets = [];
      let explosions = [];

      // Background particles
      let particles = [];

      const formation = {
        rows: 4,
        cols: 8,
        enemyWidth: 35,
        enemyHeight: 35,
        spacingX: 15,
        spacingY: 15,
        x: 60,
        y: 40,
        dx: 1.2,
        dy: 15,
        direction: 1,
        enemies: []
      };

      function createEnemyFormation() {
        formation.enemies = [];
        for (let r = 0; r < formation.rows; r++) {
          for (let c = 0; c < formation.cols; c++) {
            const enemy = {
              x: formation.x + c * (formation.enemyWidth + formation.spacingX),
              y: formation.y + r * (formation.enemyHeight + formation.spacingY),
              width: formation.enemyWidth,
              height: formation.enemyHeight,
              hp: 1,
              // Different colors for different rows
              color: r === 0 ? '#ff1744' : 
                    r === 1 ? '#ff9100' : 
                    r === 2 ? '#ffea00' : 
                    '#76ff03'
            };
            formation.enemies.push(enemy);
          }
        }
      }

      const keys = {};
      window.addEventListener("keydown", (e) => { keys[e.key] = true; });
      window.addEventListener("keyup", (e) => { keys[e.key] = false; });

      function drawSpaceship(x, y, width, height, color) {
        ctx.save();
        ctx.translate(x + width/2, y + height/2);
        
        // Glow effect
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;
        
        // Main body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(0, -height/2);
        ctx.lineTo(width/2, height/3);
        ctx.lineTo(width/3, height/2);
        ctx.lineTo(-width/3, height/2);
        ctx.lineTo(-width/2, height/3);
        ctx.closePath();
        ctx.fill();
        
        // Cockpit
        ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(0, 0, width/4, height/4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Engines
        ctx.fillStyle = color === '#00ff7f' ? '#ffffff' : '#ff6d00';
        ctx.beginPath();
        ctx.rect(-width/3, height/2, width/6, height/6);
        ctx.rect(width/6, height/2, width/6, height/6);
        ctx.fill();
        
        // Engine glow
        ctx.fillStyle = color === '#00ff7f' ? 'rgba(0, 255, 255, 0.7)' : 'rgba(255, 69, 0, 0.7)';
        ctx.beginPath();
        ctx.moveTo(-width/3 + width/12, height/2 + height/6);
        ctx.lineTo(-width/3, height/2 + height/6 + height/4);
        ctx.lineTo(-width/3 + width/6, height/2 + height/6 + height/4);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(width/6 + width/12, height/2 + height/6);
        ctx.lineTo(width/6, height/2 + height/6 + height/4);
        ctx.lineTo(width/6 + width/6, height/2 + height/6 + height/4);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }

      function drawEnemy(enemy) {
        ctx.save();
        ctx.translate(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
        
        // Glow effect
        ctx.shadowColor = enemy.color;
        ctx.shadowBlur = 10;
        
        // Main body
        ctx.fillStyle = enemy.color;
        
        // Draw an alien-like shape
        ctx.beginPath();
        // Head dome
        ctx.ellipse(0, -enemy.height/4, enemy.width/2, enemy.height/3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.beginPath();
        ctx.moveTo(-enemy.width/2, -enemy.height/6);
        ctx.lineTo(enemy.width/2, -enemy.height/6);
        ctx.lineTo(enemy.width/3, enemy.height/2);
        ctx.lineTo(-enemy.width/3, enemy.height/2);
        ctx.closePath();
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.beginPath();
        ctx.ellipse(-enemy.width/6, -enemy.height/4, enemy.width/10, enemy.height/8, 0, 0, Math.PI * 2);
        ctx.ellipse(enemy.width/6, -enemy.height/4, enemy.width/10, enemy.height/8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Tentacles
        ctx.strokeStyle = enemy.color;
        ctx.lineWidth = 3;
        
        // Left tentacle
        ctx.beginPath();
        ctx.moveTo(-enemy.width/3, enemy.height/2);
        ctx.quadraticCurveTo(-enemy.width/2, enemy.height, -enemy.width/3, enemy.height);
        ctx.stroke();
        
        // Right tentacle
        ctx.beginPath();
        ctx.moveTo(enemy.width/3, enemy.height/2);
        ctx.quadraticCurveTo(enemy.width/2, enemy.height, enemy.width/3, enemy.height);
        ctx.stroke();
        
        ctx.restore();
      }

      function createExplosion(x, y, color, size = 1) {
        // Create multiple explosion particles
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 3 + 1;
          const radius = Math.random() * 3 * size + 2;
          const lifetime = Math.random() * 40 + 20;
          
          particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: radius,
            color: color,
            alpha: 1,
            lifetime: lifetime,
            currentLife: 0
          });
        }
        
        // Add a shockwave effect
        explosions.push({
          x: x,
          y: y,
          radius: 5,
          maxRadius: 60 * size,
          color: color,
          alpha: 0.7,
          speed: 1.5
        });
      }
      
      function drawBullet(bullet) {
        ctx.save();
        
        if (bullet.type === "bullet") {
          // Regular bullet
          ctx.fillStyle = "#00ffff";
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 10;
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
          
          // Add a particle trail to bullets
          if (Math.random() > 0.5) {
            particles.push({
              x: bullet.x + bullet.width / 2,
              y: bullet.y + bullet.height,
              vx: (Math.random() - 0.5) * 1,
              vy: Math.random() * 1 + 1,
              radius: Math.random() * 2 + 0.5,
              color: "#00ffff",
              alpha: 0.7,
              lifetime: 20,
              currentLife: 0
            });
          }
        } else if (bullet.type === "bomb") {
          // Bomb bullet - more complex design
          ctx.fillStyle = "#ff6600";
          ctx.shadowColor = "#ff6600";
          ctx.shadowBlur = 15;
          
          // Draw the bomb body
          ctx.beginPath();
          ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/1.5, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw the wick
          ctx.strokeStyle = "#ffdd00";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(bullet.x + bullet.width/2, bullet.y);
          ctx.lineTo(bullet.x + bullet.width/2, bullet.y - 5);
          ctx.stroke();
          
          // Add spark particles to the bombs
          if (Math.random() > 0.3) {
            const sparkAngle = Math.random() * Math.PI * 2;
            particles.push({
              x: bullet.x + bullet.width/2,
              y: bullet.y - 5,
              vx: Math.cos(sparkAngle) * 0.5,
              vy: Math.sin(sparkAngle) * 0.5,
              radius: Math.random() + 0.5,
              color: "#ffff00",
              alpha: 1,
              lifetime: 10,
              currentLife: 0
            });
          }
        }
        
        ctx.restore();
      }
      
      function updateParticles() {
        // Update all particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.currentLife++;
          p.alpha = 1 - (p.currentLife / p.lifetime);
          
          // Remove dead particles
          if (p.currentLife >= p.lifetime) {
            particles.splice(i, 1);
          }
        }
        
        // Update all explosions (shockwaves)
        for (let i = explosions.length - 1; i >= 0; i--) {
          const exp = explosions[i];
          exp.radius += exp.speed;
          exp.alpha -= 0.02;
          
          // Remove faded explosions
          if (exp.alpha <= 0 || exp.radius >= exp.maxRadius) {
            explosions.splice(i, 1);
          }
        }
      }
      
      function drawParticles() {
        // Draw all particles
        particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.alpha;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        
        // Draw all explosions (shockwaves)
        explosions.forEach(exp => {
          ctx.save();
          ctx.globalAlpha = exp.alpha;
          ctx.strokeStyle = exp.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        });
      }
      
      function updateStars() {
        stars.forEach(star => {
          star.y += star.speed;
          if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
          }
        });
      }
      
      function drawStars() {
        ctx.fillStyle = "#ffffff";
        stars.forEach(star => {
          ctx.save();
          ctx.globalAlpha = Math.random() * 0.5 + 0.5;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      function clashGameLoop() {
        if(!clashGameRunning) return;

        let elapsed = (Date.now() - miniGameStartTime) / 1000;
        if(elapsed >= miniGameTimeLimit) {
          endElectronClash(true);
          return;
        }

        // Clear the screen with a gradient background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw the animated starfield background
        updateStars();
        drawStars();
        
        // Update and draw all particles
        updateParticles();
        drawParticles();

        // Handle player movement
        if(keys["ArrowLeft"] && shooter.x > 0) {
          shooter.x -= shooter.speed;
        }
        if(keys["ArrowRight"] && shooter.x + shooter.width < canvas.width) {
          shooter.x += shooter.speed;
        }
        
        // Handle shooting
        if(keys[" "] && shooter.cooldown <= 0) {
          bullets.push({ 
            x: shooter.x + shooter.width/2 - 2, 
            y: shooter.y, 
            width: 4, 
            height: 12, 
            damage: shooter.attack, 
            type: "bullet" 
          });
          shooter.cooldown = bulletCooldown;
          playSound('shoot');
        }
        
        if(keys["b"] && currentBombCooldown <= 0 && bombBullets.length === 0 && bombs > 0) {
          bombBullets.push({ 
            x: shooter.x + shooter.width/2 - 6, 
            y: shooter.y, 
            width: 12, 
            height: 15, 
            damage: shooter.attack, 
            type: "bomb" 
          });
          currentBombCooldown = bombCooldown;
          bombs--;
          updateProgress();
          playSound('bomb');
        }
        
        if(shooter.cooldown > 0) shooter.cooldown--;
        if(currentBombCooldown > 0) currentBombCooldown--;

        // Draw the player spaceship
        drawSpaceship(shooter.x, shooter.y, shooter.width, shooter.height, shooter.color);

        // Update and draw bullets
        for(let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          b.y -= 8;
          drawBullet(b);
          if(b.y + b.height < 0) bullets.splice(i, 1);
        }
        
        for(let i = bombBullets.length - 1; i >= 0; i--) {
          let b = bombBullets[i];
          b.y -= 6;
          drawBullet(b);
          if(b.y + b.height < 0) bombBullets.splice(i, 1);
        }

        // Update enemy formation movement
        let minX = Infinity, maxX = -Infinity;
        formation.enemies.forEach(enemy => {
          if(enemy.x < minX) minX = enemy.x;
          if(enemy.x + enemy.width > maxX) maxX = enemy.x + enemy.width;
        });
        
        if(minX <= 0 || maxX >= canvas.width) {
          formation.direction *= -1;
          formation.enemies.forEach(enemy => {
            enemy.y += formation.dy;
          });
        }
        
        formation.enemies.forEach(enemy => {
          enemy.x += formation.dx * formation.direction;
        });

        let bombExplosionHappened = false;
        let explosionCenterX = 0;
        let explosionCenterY = 0;

        // Check for collisions and draw enemies
        outerLoop:
        for(let i = formation.enemies.length - 1; i >= 0; i--) {
          let enemy = formation.enemies[i];
          drawEnemy(enemy);

          // Check bullet collisions
          for(let j = bullets.length - 1; j >= 0; j--) {
            let b = bullets[j];
            if(b.x < enemy.x + enemy.width &&
               b.x + b.width > enemy.x &&
               b.y < enemy.y + enemy.height &&
               b.y + b.height > enemy.y) {
              enemy.hp -= b.damage;
              bullets.splice(j, 1);
              
              // Create a small explosion at hit location
              createExplosion(
                b.x + b.width/2,
                b.y,
                enemy.color,
                0.5
              );
              
              if(enemy.hp <= 0) {
                clashScore += 10;
                // Create a full explosion when enemy is destroyed
                createExplosion(
                  enemy.x + enemy.width/2,
                  enemy.y + enemy.height/2,
                  enemy.color
                );
                playSound('explosion');
                formation.enemies.splice(i, 1);
                continue outerLoop;
              }
            }
          }
          
          // Check bomb collisions
          for(let j = bombBullets.length - 1; j >= 0; j--) {
            let b = bombBullets[j];
            if(b.x < enemy.x + enemy.width &&
               b.x + b.width > enemy.x &&
               b.y < enemy.y + enemy.height &&
               b.y + b.height > enemy.y) {
              explosionCenterX = enemy.x + enemy.width / 2;
              explosionCenterY = enemy.y + enemy.height / 2;
              bombExplosionHappened = true;
              bombBullets.splice(j, 1);
              clashScore += 30;
              // Create a large explosion for bomb hit
              createExplosion(
                explosionCenterX,
                explosionCenterY,
                "#ff6600",
                3
              );
              playSound('explosion');
              break outerLoop;
            }
          }
          
          // Check if enemies reached the bottom
          if(enemy.y + enemy.height >= canvas.height - 20) {
            endElectronClash(false);
            return;
          }
        }

        // Handle bomb explosion area damage
        if(bombExplosionHappened) {
          formation.enemies = formation.enemies.filter(en => {
            let enCenterX = en.x + en.width/2;
            let enCenterY = en.y + en.height/2;
            let dx = enCenterX - explosionCenterX;
            let dy = enCenterY - explosionCenterY;
            let distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance <= 80) {
              // Create small explosion for each enemy caught in blast
              createExplosion(
                enCenterX,
                enCenterY,
                en.color
              );
              return false; // Remove this enemy
            }
            return true;
          });
        }

        // Create new enemy formation when all enemies are defeated
        if(formation.enemies.length === 0) {
          createEnemyFormation();
        }

        // Update game HUD
        document.getElementById("clashScore").innerText =
          `Score: ${clashScore} | Time: ${Math.floor(elapsed)}s | Bombs: ${bombs}`;
          
        // Draw time bar
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(10, 10, canvas.width - 20, 15);
        
        ctx.fillStyle = "#00ff7f";
        const timeBarWidth = (1 - elapsed / miniGameTimeLimit) * (canvas.width - 20);
        ctx.fillRect(10, 10, timeBarWidth, 15);
        
        requestAnimationFrame(clashGameLoop);
      }

      function launchElectronClash() {
        atomBuilderDiv.style.display = "none";
        gameHUD.style.display = "none";
        electronClashDiv.style.display = "block";
        clashScore = 0;
        bullets = [];
        bombBullets = [];
        particles = [];
        explosions = [];
        shooter.x = canvas.width / 2 - 20;
        shooter.cooldown = 0;
        shooter.speed = 6;
        shooter.attack = 1;
        currentBombCooldown = 0;
        formation.direction = 1;
        formation.dx = 1.2;
        formation.rows = 4;
        createEnemyFormation();
        miniGameStartTime = Date.now();
        clashGameRunning = true;
        requestAnimationFrame(clashGameLoop);
      }

      function endElectronClash(win) {
        clashGameRunning = false;
        
        if(win) {
          // Create win feedback
          const feedback = document.createElement('div');
          feedback.classList.add('correct-feedback');
          feedback.style.fontSize = '4em';
          feedback.innerText = `TIME'S UP! SCORE: ${clashScore}`;
          document.body.appendChild(feedback);
          
          // Remove feedback after animation completes
          setTimeout(() => {
            document.body.removeChild(feedback);
            // Continue with game flow
            displayResults();
          }, 2000);
          
          playSound('correct');
        } else {
          // Create lose feedback
          const feedback = document.createElement('div');
          feedback.classList.add('incorrect-feedback');
          feedback.style.fontSize = '4em';
          feedback.innerText = `EARTH INVADED! SCORE: ${clashScore}`;
          document.body.appendChild(feedback);
          
          // Remove feedback after animation completes
          setTimeout(() => {
            document.body.removeChild(feedback);
            // Continue with game flow
            displayResults();
          }, 2000);
          
          playSound('incorrect');
        }
        
        function displayResults() {
          clashScoreTotal += clashScore;
          electronClashDiv.style.display = "none";
          atomBuilderDiv.style.display = "block";
          gameHUD.style.display = "flex";
          newAtomRound();
        }
      }

      document.getElementById("exitClashBtn").addEventListener("click", function() {
        endElectronClash(false);
      });
    });
  </script>
</body>
</html>
